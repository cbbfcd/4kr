# Rust 程序语言设计第二版

> 简单的记录一点笔记，最最基础的东西

## 变量和可变性

使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。

对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的

```rust
// 变量默认是 immutable 的
let x: u32 = 5;

// 可变变量 mut
let mut y: u32 = 5;

// 常量
// ⚠️变量虽然默认不可变，但是也不是等于就是常量了，语法上必须使用 const，不能有 mut，必须注明类型，总是不可变
const MAX: u32 = 10000;
```

常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。

最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。

### 隐藏（Shadowing）

说白了就是第二次声明覆盖了第一次的声明，但是还是能取到值。

```rust
let x = 5; // 此时，x => 5

let x = x + 1; // 隐藏了上面的声明，此时，x => 6

let x = x * 2; // 隐藏了上面的声明，此时，x => 12
```

`let` 不可少！计算完之后变量仍然是不变的。

隐藏与 `mut` 本质上是不一样的，而且隐藏有一个很有用的地方，就是可以改变数据类型，这在 `mut` 中是无法办到的，虽然可变变量支持重新赋值，但是类型要求一致

```rust
let spaces = "   "; // 字符串

let spaces = spaces.len(); // 数值
```

如果是 `mut` 就会报错了，因为变量不可以改变类型

```rust
let mut spaces = "   "; // 字符串

spaces = spaces.len(); // 报错
```

## 数据类型

`Rust` 是静态类型（`statically typed`）语言，也就是说在编译时就必须知道所有变量的类型

我们将看到两类数据类型子集：标量（`scalar`）和复合（`compound`）

### 标量类型

`Rust` 有四种基本的标量类型：**整型、浮点型、布尔类型和字符类型**

#### 整型

`Rust` 中的整型：

| 长度 | 有符号 | 无符号 |
| :----: | :----: | :----: |
| 8-bit | i8 | u8 |
| 16-bit | i16 | u16 |
| 32-bit | i32 | u32 |
| 64-bit | i64 | u64 |
| 128-bit | i128 | u128 |
| arch | isize | usize |


*有符号* 和 *无符号* 代表数字能否为负值, 有符号数以补码形式（`two’s complement representation`） 存储。

`i8` 可以储存从 `-2 ^ 7` 到 `2 ^ 7 - 1` 在内的数字，也就是从 `-128` 到 `127`。无符号的变体可以储存从 `0` 到 `2n - 1` 的数字，所以 `u8` 可以储存从 `0` 到 `2 ^ 8 - 1` 的数字，也就是从 `0` 到 `255`

> 有符号位，符号就占了一位，表示正负，所以最大是 `2 ^ (n - 1) - 1`。无符号位则是 `2 ^ n - 1`

**`isize` 和 `usize` 类型依赖运行程序的计算机架构：`64` 位架构上它们是 `64` 位的， `32` 位架构上它们是 `32` 位的**



### 

